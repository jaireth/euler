// Cyclical figurate numbers
// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
// Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
// Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
// Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
// Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
// Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
// Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

//     The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
//     Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
//     This is the only set of 4-digit numbers with this property.

// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.


// So, first we can find the cyclic? No, there's less Octogonal than any of them, right?


let getTriangle = (n) => n * (n + 1) / 2
let getSquare = (n) => n * n
let getPentagonal = (n) => n * ((3 * n) - 1) / 2
let getHexagonal = (n) => n * ((2 * n) - 1)
let getHeptagonal = (n) => n * ((5 * n) - 3) / 2
let getOctogonal = (n) => n * ((3 * n) - 2)


let getFigurates = (formula, min, max) => {
    let ret = []
    for (let n = 0; n < 99999; n++) {
        let num = formula(n)
        if (num > max) break
        if (num >= min) {
            ret.push({ num, leftPair: [], rightPair: [] })
        }
    }

    return ret
}

// console.log(getFigurates(getTriangle, 0, 20))
// console.log(getFigurates(getSquare, 0, 30))
// console.log(getFigurates(getPentagonal, 0, 40))
// console.log(getFigurates(getHexagonal, 0, 50))
// console.log(getFigurates(getHeptagonal, 0, 60))
// console.log(getFigurates(getOctogonal, 0, 70))



let triangles = getFigurates(getTriangle, 1000, 9999)
let squares = getFigurates(getSquare, 1000, 9999)
let pentagonals = getFigurates(getPentagonal, 1000, 9999)
let hexagonals = getFigurates(getHexagonal, 1000, 9999)
let heptagonals = getFigurates(getHeptagonal, 1000, 9999)
let octogonals = getFigurates(getOctogonal, 1000, 9999)

let numbers = []
numbers[0] = triangles
numbers[1] = squares
numbers[2] = pentagonals
numbers[3] = hexagonals
numbers[4] = heptagonals
numbers[5] = octogonals


// console.log(numbers[0].length)
// console.log(numbers[1].length)
// console.log(numbers[2].length)
// console.log(numbers[3].length)
// console.log(numbers[4].length)
// console.log(numbers[5].length)

for (let i = 0; i < numbers.length; i++) {
    let num1s = numbers[i]
    for (let j = i + 1; j < numbers.length; j++) {
        let num2s = numbers[j]

        for (let iNum1 = 0; iNum1 < num1s.length; iNum1++) {
            let num1 = num1s[iNum1]
            for (let iNum2 = 0; iNum2 < num2s.length; iNum2++) {
                let num2 = num2s[iNum2]
                // I will hit this twice and fill in the other way around...
                if (Math.floor(num1.num / 100) == num2.num % 100) {
                    num1.leftPair.push({ i: j, iNum: iNum2 }) // index of the list, and index of the item in that list
                    num2.rightPair.push({ i, iNum: iNum1 })
                    //console.log(Math.floor(num1 / 100), num2 % 100 || num1 % 100, Math.floor(num2 / 100))
                    //pairs.push({ i, num1, iNum1, j, num2, iNum2 }) // list, number, numbers place in list, repeat
                    //return
                }
                if (num1.num % 100 == Math.floor(num2.num / 100)) {
                    num1.rightPair.push({ i: j, iNum: iNum2 })
                    num2.leftPair.push({ i, iNum: iNum1 })
                }


            }

        }

    }
}

let pairs = []

for (let i = 0; i < numbers.length; i++) {
    pairs[i] = numbers[i].filter(num => num.leftPair.length > 0 && num.rightPair.length > 0)
}


console.log(numbers[0].length, pairs[0].length)
console.log(numbers[1].length, pairs[1].length)
console.log(numbers[2].length, pairs[2].length)
console.log(numbers[3].length, pairs[3].length)
console.log(numbers[4].length, pairs[4].length)
console.log(numbers[5].length, pairs[5].length)


let find = (num, arr, i, iArr) => {
    iArr.push(i)
    // if we have 6, and our new entry is the same as the first, return true!
    // if (arr.length == 5) { // we found a link of 6, if it's circular, return true!
    //     console.log(5, arr) // let's see the "almosts"
    // }

    if (iArr.length == 6) {
        console.log('iArr2', iArr) // because of copies
        console.log('answer2', arr) // because of copies     
    }
    if (arr.length == 6) { // we found a link of 6, if it's circular, return true!
        //console.log(6, arr) // let's see the "almosts"
        // TODO: if false, do we need to remove from arr?
        //return (arr[0].i == num.i && arr[0].iNum == num.iNum)
        let ret = (arr[0] == num.num)
        if (ret) {
            console.log('iArr', iArr) // because of copies
            console.log('answer', arr) // because of copies
        }
        return ret // not perfect because those two numbers could be the same number in two different lists!
    }

    // TODO: need to make sure we don't have two of the same kind - if we get more than one we can see...
    // not 6 yet, add one and keep going (for 7, which may be the one we want)
    arr.push(num.num)
    //console.log(arr)
    //console.log(arr.length)
    //console.log('num', num)
    //console.log(num.rightPair)
    for (let r = 0; r < num.rightPair.length; r++) {
        // if it's length of 6, then we have 6 uniques, the last one is definitely a dupe, but it's also a possible answer.
        //console.log(iArr)
        if (iArr.length < 7 && iArr.filter(ii => ii == num.rightPair[r].i).length != 0) return false // if we already have one of this number list, stop
        // has to be numbers to find the pair, but it's the same object, so
        let rightNum = numbers[num.rightPair[r].i][num.rightPair[r].iNum]
        // console.log(iArr)
        // console.log(arr)
        
        
        //console.log(num.rightPair[r])
        //console.log('rightNum', rightNum)
//        console.log('test', arr, arr.slice(0))
        let f = find(rightNum, arr.slice(0), num.rightPair[r].i, iArr.slice(0)) // passing a copy of the array these days!
        if (f) return true
    }
}

// TODO: loop through the pairs and find a way through? But I need to follow in different orders? No, just don't go to the same twice!
let arrFound = []
//for (let n = 0; n < pairs.length; n++) {
let pair = pairs[0] // why not just start with 0 only!
for (let i = 0; i < pair.length; i++) {
    let arr = []
    let iArr = [0]
    let num = pair[i]
    let found = find(num, arr, 0, iArr)
    if (found) {
        arrFound.push(arr.map(num => num.num))

    }


}
//}

console.log(arrFound)

// let iNum = pairs[0][i]
// for (let j = 0; i < pairs[1].length; j++) {
//     let jNum = pairs[0][j]
//     for (let k = 0; i < pairs[2].length; k++) {
//         let kNum = pairs[0][k]
//         for (let l = 0; i < pairs[3].length; l++) {
//             let lNum = pairs[0][l]
//             for (let m = 0; i < pairs[4].length; m++) {
//                 let mNum = pairs[0][m]
//                 for (let n = 0; i < pairs[5].length; n++) {
//                     let nNum = pairs[0][n]
//                 }
//             }
//         }
//     }
// }


// - I should be adding to a larger object above...

// console.log(pairs.length)
// console.log(pairs[0])

// for (let iOct = 0; iOct < octogonals.length; iOct++) {
//     let octagonal = octogonals[iOct]
//     for (let iHept = 0; iHept < heptagonals.length; iHept++) {
//         let heptagonal = heptagonals[iHept]
//         if (octagonal / 1000 == heptagonal % 1000 || octagonal % 1000 == heptagonal / 1000) {
//             console.log(octogonal, heptagonal)
//         }


//     }

// }


